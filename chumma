import numpy as np
from scipy import signal
import matplotlib.pyplot as plt
from matplotlib.pyplot import plot, show, title
ppg=np.loadtxt(r’C:3.txt’)
ecg =np.loadtxt(r’C:3.txt’)
#filtering
fs=125
q=len(ecg)

gg=ecg[1:q]
cf1 = 1
w1 = cf1 / (fs / 2)
b, a = signal.butter(2, w1,’high’)
output1 = signal.filtfilt(b, a, gg)
cf2 = 30
w2 = cf2 / (fs / 2)
d, c = signal.butter(5, w2,’low’)
e = signal.filtfilt(d, c, output1)
r=len(ppg)
g=ppg[1:r]
fss=125
fc3 = .63
w3 = fc3 / (fss / 2)
u, v = signal.butter(2, w3,’high’)
output2 = signal.filtfilt(u, v, g)
fc4 = 10
w4 = fc4 / (fss / 2)
j1, c1 = signal.butter(2, w2, ’low’)
y = signal.filtfilt(j1, c1, output2)
#plots plt.figure(1)
plt.subplot(3,3,1)
plt.plot(gg)
plt.xlabel(’samples’)
plt.ylabel(’amplitude’)
plt.title(’ecg signal’)
plt.show()
plt.figure(1)
plt.subplot(3,3,2)
plt.xlabel(’samples’)
plt.ylabel(’amplitude’)
title(’ppg signal’)
plt.plot(g)
plt.show()
plt.figure(1)
plt.subplot(3,2,1)
plt.xlabel(’samples’)
plt.ylabel(’amplitude’)
title(’filtered ecg signal’)
plt.plot(e)
plt.show()
plt.figure(1)
plt.subplot(3,3,3)
plt.xlabel(’samples’)
plt.ylabel(’amplitude’)
title(’filtered ppg signal’)
plt.plot(y)
plt.show()
ecg rpeak and time index
m=np.max(e)
th=0.4*m# setting threshold
a=1
r=[]
ri=[]
for i in range(0,len(e)):
if e[i]>th and e[i]>e[i+1] and e[i]>e[i-1]:# Rpeak and time index
r.append(e[i])
ri.append(i)
#rr interval
rr=[]
f=len(ri)
for j in range(0,f-1):#RR interval
rr.append( ri[j + 1] - ri[j])
print(”rr=”,rr)
#heart rate
sum1 = 0
t=len(rr)
for k in range(t) :
sum1+= rr[k]
avg = sum1/t
hr1 = 60/avg
hr = hr1*125
print(’heartrate =’,hr)
#ppg systolic peak detection
t1 = max(y)
th1 = 0.5*t1
sys peak i = []
sys peak = []
j=0
for j in range(len(y)):#systolic and diastolic values
if y[j]>th1 and y[j]>y[j+1] and y[j]>y[j-1]:
sys peak.append(y[j])
sys peak i.append(j)
print(’ppg peaks =’, sys peak)
print(’Time index of systolic peak =’,sys peak i)
#ppg diastolic peak detection
dias peak i=[]
dias peak=[]
for k in range(len(sys peak i)-1):
for i3 in range(sys peak i[k]+1,sys peak i[k+1]-1):
if y[i3]>y[i3+1] and y[i3]>y[i3-1]:
dias peak.append(y[i3])
print(”dbp=”,dias peak i)
#ptt
s = []
v=len(sys peak i)-len(ri)
g=0
for g in range(v):
ri.append(0)
for l in range(len(sys peak i)):
if ri[l]!=0:
s.append(sys peak i[l]-ri[l])#difference between the time index of R peak and systolic peak
else:
break
print(’ptt =’,s)
#matrix
sp=np.loadtxt(r’C:3.txt’)
dp=np.loadtxt(r’C:(1).txt’)
g5=len(s)
g5=len(s)
print(g5)
hr2=np.loadtxt(r’C:3.txt’)
print(’len of hr=’,len(hr2))
w6=g5-len(sp)
e1 = 0
if len(hr2)>len(s):
d1 = len(hr2) - len(s)
for e1 in range(w6):
sp=np.append(sp,0)
dp=np.append(dp,0)
print(’sbp list=’, sp)
print(’dbp list=’, dp)
a1 = np.array([sp, dp])
b1 = np.asmatrix(a1)
c5 = np.transpose(b1)#SBP and DBP matrix
print(’matrix Y=’,c5)
print(len(sp))
for m6 in range(d1):
s.append(0)
i5 = np.ones(len(hr2)) * 1
sp=np.append(sp,0)
dp=np.append(dp,0)
h5 = np.array([s, hr2, i5])
m5 = np.asmatrix(h5)
n5 = np.transpose(m5)
print(’matrix x=’, n5)
print(’sbp list=’, sp)
print(’dbp list=’, dp)
a1 = np.array([sp, dp])
b1 = np.asmatrix(a1)
c5 = np.transpose(b1)
else:
d2 = len(s) - len(hr2)
for e1 in range(w6):
sp = np.append(sp, 0)
dp = np.append(dp, 0)
print(’sbp list=’, sp)
print(’dbp list=’, dp)
a1 = np.array([sp, dp])
b1 = np.asmatrix(a1)
c5 = np.transpose(b1)
print(len(sp))
for m6 in range(d2):
s.append(0)
i5 = np.ones(len(hr2)) * 1
sp = np.append(sp, 0)
dp = np.append(dp, 0)
h5 = np.array([s, hr2, i5])
m5 = np.asmatrix(h5)
n5 = np.transpose(m5)
print(’matrix x=’, n5)
a1 = np.array([sp, dp])
b1 = np.asmatrix(a1)
c5 = np.transpose(b1)
#theta
q5=np.conjugate(n5)
p5=m5.dot(n5)
print(’xT*x=’,p5) ˆ
r5=np.linalg.inv(p5)
print(’inverse =’,r5)
s5=q5.dot(r5)
print(’inverse * conj =’,s5)
u5=np.transpose(s5)
t5=u5.dot(c5)
print(’theta=’,t5)
#sbp and dbp
x5=np.mean(s)
v5=t5[0,0]
y5=t5[0,1]
w5=t5[1,0]
z5=t5[1,1]
a6=t5[2,0]
b6=t5[2,1]
print(’a1=’,v5)
print(’a2=’,y5)
print(’b1=’,w5)
print(’b2=’,z5)
print(’c1=’,a6)
print(’c2=’,b6)
c6=v5*x5
d6=w5*hr2
sbp=c6+d6+a6
print(’sbp=’,sbp)#List of SBP values
plt.figure(2)
plt.xlabel(’data number’)
plt.ylabel(’sbp(mmhg)’)
title(’sbp’)
plt.plot(sbp)
plt.show()#plot of SBP
mn=np.mean(sbp)#mean of SBP
print(”mn=”,mn)
e6=y5*x5
f6=z5*hr2
dbp=e6+f6+b6
print(’dbp=’,dbp)#List of DBP values
plt.figure(2)
plt.xlabel(’data number’)
plt.ylabel(’dbp(mmhg)’)
title(’dbp’)
plt.plot(dbp)
plt.plot(x,y)
plt.plot(y,x)
plt.show()#plot of DBP
nm=np.mean(dbp)#mean of DBP
print(”nm=”,nm)
      Algorithm To Determine BPV
Step 0: Start
Step 1: PPG acquisition using the sensor module
Step 2:Highest value of the discretized output is stored
Step 3: Set a threshold value
Step 4:values greater than the threshold and their index are stored
Step 5:using turning point algorithm Systolic and Diastolic peak and their index is obtained
Step 6:Difference between an R-peak(obtained for HRV estimation) and a systolic peak gives PTT
Step 7: Load the values of SBP and DBP of N observations in a matrix Y
Yi:N =






SBP(i1) DBP(i1)
... ...
SBP(iN) DBP(iN)






Step 8: Load the values of PTT and HR of N observations in a matrix X
Xi:N =






P AT(i1) HR(i1) 1
... ... ...
P AT(iN) HR(iN) 1






Step 9: Find the transpose of matrix X
Step 10: Find the inverse of matrix
Step 11: Find the conjugate of matrix X
Step 12:Obtain θ
θN = [XT
1:N X1:N ]
−1X∗
1:N Y1:N (4.3)
θ =






a1 a2
b1 b2
c1 c2






Step 13: Substitute the values of in the formula and find the values of SBP and DBP
SBP = a1 ∗ P T T + b1 ∗ HR + c1 (4.4)
DBP = a2 ∗ P T T + b2 ∗ HR + c2 (4.5)
Step 14: Find the mean , standard deviation , skewness and kurtosis
Step 15: Obtain the power spectrum density
Step 16: Obtain low frequency (LF ) high frequency(HF) components
Step 17: Then take the ratio of LF/HF
Step 18:α, βandγfeaturesarealsoobtained
α = [p
(SD/m)
2 + SK2 + K2]hrv/[
p
(SD/m)
2 + SK2 + K2]bpv (4.6)
β = (LF/HF)hrv/(LF/HF)bpv (4.7)
γ = (SD2/SD1)hrv (4.8)
γ = (SD2/SD1)bpv (4.9)
step 19:A trend graph is displayed based on the observations
step 20:Stop
